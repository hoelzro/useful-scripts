#!/usr/bin/env python

from datetime import datetime, timedelta, timezone
import itertools
import re
import sys

from dateutil import tz

dst_aware_tz = tz.gettz()

filename = '/var/log/Xorg.0.log' if len(sys.argv) == 1 else sys.argv[1]

with open(filename, 'r') as f:
    buffered_lines = []
    start_time = None

    for line in f:
        buffered_lines.append(line)
        if m := re.match(r'^\[(.*?)\].*Log file:.*Time:\s+(.*)', line):
            start_time = datetime.strptime(m.group(2), '%a %b %d %H:%M:%S %Y')
            start_time -= timedelta(seconds=float(m.group(1)))
            abs_tz = timezone(dst_aware_tz.utcoffset(start_time))
            start_time = start_time.replace(tzinfo=abs_tz)
            break

    previous_timestamp = 0
    timestamp_roll_offset = 0

    for line in itertools.chain(buffered_lines, f):
        if m := re.match(r'^\[\s*(\d+[.]\d+)\]', line):
            timestamp = float(m.group(1))
            if timestamp < previous_timestamp:
                # I don't think that using previous_timestamp is 100% accurate here - if, say, 15
                # minutes elapsed between the two events our offset is probably going to be off by
                # 15 minutes, but this is the best I can do!
                timestamp_roll_offset += previous_timestamp
            previous_timestamp = timestamp

        line = re.sub(r'^\[(.*?)\]', lambda m: f'[{(start_time + timedelta(seconds=timestamp_roll_offset + float(m.group(1)))).astimezone(dst_aware_tz)}]', line)
        print(line, end='')
