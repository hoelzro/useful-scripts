#!/usr/bin/env python

from datetime import datetime, timedelta, timezone
import itertools
import re
import sys

from dateutil import tz

# xorg-server uses GetTimeInMillis() for timestamp logging, which (depending on compilation options),
# returns the time since boot in milliseconds as a 32-bit value, which the logger then divides by
# 1,000 to get the value in seconds.  This means that it rolls every 4.3 million seconds or so - so
# compensate for that
MAX_TIMESTAMP_SECONDS = (1 << 32) / 1_000

dst_aware_tz = tz.gettz()

filename = '/var/log/Xorg.0.log' if len(sys.argv) == 1 else sys.argv[1]

with open(filename, 'r') as f:
    buffered_lines = []
    start_time = None

    for line in f:
        buffered_lines.append(line)
        if m := re.match(r'^\[(.*?)\].*Log file:.*Time:\s+(.*)', line):
            start_time = datetime.strptime(m.group(2), '%a %b %d %H:%M:%S %Y')
            start_time -= timedelta(seconds=float(m.group(1)))
            abs_tz = timezone(dst_aware_tz.utcoffset(start_time))
            start_time = start_time.replace(tzinfo=abs_tz)
            break

    previous_timestamp = 0
    timestamp_roll_offset = 0

    for line in itertools.chain(buffered_lines, f):
        if m := re.match(r'^\[\s*(\d+[.]\d+)\]', line):
            timestamp = float(m.group(1))
            if timestamp < previous_timestamp:
                timestamp_roll_offset += MAX_TIMESTAMP_SECONDS
            previous_timestamp = timestamp

        line = re.sub(r'^\[(.*?)\]', lambda m: f'[{(start_time + timedelta(seconds=timestamp_roll_offset + float(m.group(1)))).astimezone(dst_aware_tz)}]', line)
        print(line, end='')
